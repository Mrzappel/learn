### 事件循环

异步任务很耗时，为了不至于让页面处理冻结状态，渲染主线程，所以配合webAPi和事件循环，将异步任务分成许多小任务，

具体是通过事件队列完成，所有任务先在队列中排队，其中有微任务队列和宏任务队列，当执行栈为空时，不断从微任务队列中取出任务执行，当微任务队列为空时，再从宏任务队列中取出任务执行，如此循环，直到两个队列都为空，事件循环结束。

在事件循环中，确实会有两个队列：微任务队列（Microtask Queue）和宏任务队列（Macrotask Queue）。主线程执行栈为空时，事件循环会先从微任务队列中取出所有任务依次执行，然后再执行一个宏任务。这个过程会不断循环，直到两个队列都为空。

具体流程如下：

1. 执行同步任务：主线程执行同步任务，遇到异步任务时，将它交给对应的 Web API 处理，并继续执行后续的同步任务。

2. 异步任务处理：异步任务（例如定时器、网络请求等）被 Web API 处理，并在指定的时间后将回调函数加入到宏任务队列中。

3. 微任务队列：在执行栈为空时，主线程会检查微任务队列，并依次执行队列中的所有微任务。微任务通常包括 Promise 的回调、MutationObserver 回调等。

4. 宏任务队列：在执行完所有微任务后，主线程会从宏任务队列中取出一个任务执行。这个过程中可能会触发重新渲染（如果有需要）。

5. 重复循环：执行完一个宏任务后，再次检查微任务队列并依次执行，然后再从宏任务队列中取出下一个任务，以此循环。


事件循环是通过微任务队列和宏任务队列来处理异步任务，以确保主线程不会被长时间阻塞，从而提高页面的响应性和性能。
### 宏任务和微任务


